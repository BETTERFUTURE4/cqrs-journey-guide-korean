<div align="center">

#### [목차 바로가기](https://github.com/dhslrl321/cqrs-journey-guide-korean/blob/master/Table%20of%20Contents.md)

</div>

---

# Patterns and Concepts

이번 파트에서는 팀이 선택한 애플리케이션의 핵심 아키텍처에 대해서 설명하고 팀이 직면한 몇 가지 issue 들에 대해서 소개한다.

# Event Sourcing

콘토소의 팀은 원래 이벤트 소싱을 사용하지 않고 Order 와 Registration 바운디드 컨텍스트를 구현했다.

하지만 구현은 이벤트 소싱을 사용하는 것이 이 바운디드 컨텍스트를 단순화하는 데 도움이 될 것이라는 것이 분명해졌다

4장, Extending Order 및 Registration Bounded Context 에서 팀은 write side 에서 read side 로 변경 사항을 push 하기 위해 이벤트를 사용해야 한다는 것을 발견했다.

read side 에서 OrderViewModelGenerator 클래스는 Order 애그리거트에서 publish 한 이벤트를 구독하고 이러한 이벤트를 사용해서 read model 에 의해 쿼리된 데이터베이스의 뷰를 업데이트 했다

이것은 자체로도 이미 이벤트 소싱 구현의 대부분을 했다고 볼 수 있다. 그래서 결국 전체 바운디드 컨텍스트에 대한 이벤트를 기반으로 단일 데이터소스를 사용하는 것이 합리적이었다.

이벤트 소싱 및 인프라는 다른 바운디드 컨텍스트에서 재사용할 수 있으며 Order 및 Registration 구현이 더 간단해졌다

이벤트 스토어의 구현 기술을 선택할 때, 애플리케이션에서 필요한 가용성, 일관성, 신뢰성, 규모 및 성능을 제공할 수 있는지 확인해야 한다

# 애그리거트 식별하기

팀이 V1 릴리즈를 위해 만든 Event Store 는 애그리거트 ID 를 파티션 키로 사용했고 이는 특정 애그리거트에 대한 이벤트를 보유하는 파티션을 효율적으로 찾을 수 있게 해준다.

팀이 V1 릴리스를 위해 만든 이벤트 저장소의 Windows Azure 테이블 스토리지 기반 구현에서 집계 ID를 파티션 키로 사용했습니다. 이것은 특정 집계에 대한 이벤트를 보유하는 파티션을 효율적으로 찾을 수 있게 해준다.

경우에 따라서, 시스템은 특정 애그리거트를 찾아야 한다. 예를 들어, 주문 애그리거트는 특정 좌석에 배정된 참석자의 세부 사항을 담고있는 관련된 Registration 애그리거트를 가질 수 있다.

이 시나리오에서 팀은 조회를 쉽게 하기 위해서 관련된 애그리거트 페어에 대해서 동일한 애그리거트 ID 를 재사용하기로 결정했다.

더 일반적인 시나리오는 애그리거트 간의 일대다 (one-to-many) 관계를 갖는 형태이다.

이 경우, 애그리거트 ID 를 공유할 수 없다. 대신 "one" 쪽에 애그리거트의 ID list 를 저장할 수 있으며, "many" 쪽의 각 애그리거트의 ID 를 "one" 쪽에 저장할 수 있다.

> Sharing aggregate IDs is common when the aggregates exist in different bounded contexts. If you have aggre- gates in different bounded contexts that model different facets of the same real-world entity, it makes sense for them to share the same ID. This makes it easier to follow a real-world entity as different bounded contexts in your system process it. - Greg Young - Conversation with the patterns & practices team

# Task-Based UI

---
