<div align="center">

#### [목차 바로가기](https://github.com/dhslrl321/cqrs-journey-guide-korean/blob/master/Table%20of%20Contents.md)

</div>

---

# ddd 의 컨셉과 용어

이 가이드는 DDD 에 대한 사용법이나 학습법을 알려주는 가이드가 아니다.

그러나 CQRS 패턴을 구현하기 위해서 필요한 몇가지 DDD 개념들을 알아두면 도움이 된다.

- Domain Model, 도메인 모델
- Ubiquitous Language, 유비쿼터스 언어
- Entities, Value Object and services
- Aggregate and Aggregate Roots

# 도메인 모델

DDD 의 중심에는 domain model 이라는 것이 존재한다.

도메인 모델은 도메인 전문가, 비즈니스 전문가, 소프트웨어 개발자들의 토론과 여러가지의 질문들로 만들어지며 이러한 도메인 모델은 다음과 같은 역할울 수행하게 된다.

- 도메인 전문가로부터 여러 도메인 지식을을 포착할 수 있다.
- 팀이 도메인 지식에 대해서 align 할 수 있다.
- 개발자는 해당 도메인 모델을 토대로 코드를 작성한다.
- 도메인에 대한 엄청난 변화에도 즉각적으로 반영될 수 있다.

DDD 는 도메인이 곧 비즈니스 가치이기 떄문에 도메인에 집중한다.

이러한 도메인 모델을 통해서 기업은 가치를 구현하고 숨어있는 비즈니스 가치를 찾아낸다.

DDD 접근 방식의 대부분은 이러한 도메인 모델을 생성, 유지 및 사용하는 방법에 초점을 맞추고 있다.

도메인 모델은 일반적으로 Entities, Value Object and Aggregates 와 같은 요소로 구성되며 유비쿼터스 언어의 용어를 사용하여 설명한다.

# Ubiquitous Language

Ubiquitous Language 의 개념은 도메인 모델에 매우 밀접하게 닮아있다.

도메인 모델은 도메인 전문가와 개발자 사이에 대한 오해를 줄이고 같은 곳을 바라볼 수 있도록 간극을 좁히는 역할을 수행하기도 한다.

만약 도메인 전문가와 개발자가 도메인에 대해서 (앞서 Journey 파트에서 나온 콘토소 컨퍼런스 관리 시스템의 컨퍼런스, 참석자, 의자, 대기자 명단 과 같은) 동일한 용어를 사용한다면 오해에 대한 여지를 줄일 수 있게 된다.

좀 더 구체적으로는 모든 사람들이 동일한 개념의 언어를 사용한다면, 언어 간 번역으로 인한 오해가 있을 가능성이 적어진다. 예를 들어서 도메인 전문가가 참석자를 deletegtor 라고 표현하 하는데, 실제로 소프트웨어 개발자는 이를 티켓 판매원이라고 이해할 수 있고 결국 도메인에 대한 공통 개념이 없다 보니 시간이 지날수록 문제가 더 커질 수 있게 되는 것이다.

더 구체적으로, 모든 사람이 같은 언어를 사용한다면, 언어 간 번역으로 인한 오해가 있을 가능성이 적다. 예를 들어, 개발자가 "도그니 전문가가 델레 게이트에 대해 이야기한다면, 그는 실제로 소프트웨어의 참석자에 대해 이야기하고 있다"고 생각해야 한다면, 결국 이러한 명확성 부족으로 인해 무언가가 잘못될 것이다.

> 자나 : 우리의 journey 에서 우리는 SpecFlow 를 이용해서 비즈니스 룰을 표현하고 인수 테스트를 진행합니다. 그들은 우리의 도메인에 대해서 명확하고 간결한 정보 커뮤니케이션을 도와줍니다. 더 많은 정보를 얻고싶다면 Chapter 4, “Extending and Enhancing the Orders and Registrations Bounded Context” in Exploring CQRS and Event Sourcing. 를 확인하세요

# Entities, value objects, and services

DDD 는 internal artifacts (or building blocks) 를 식별하기 위해서 다음과 같은 용어를 사용한다.

### Entities

엔티티는 식별자를 가지는 객체를 의미한다. 예를 들어서 컨퍼런스 관리 시스템에서 conference 는 엔티티가 될 수 있다.

conference 의 여러 속성들은 시간이 지남에 따라서 변할 수 있지만 해당 conference 자체는 시스템 안에서 고유할 것이다.

이러한 엔티티들은 항상 시스템의 메모리상에만 존재하지 않을 수 있다. 다른 시스템에 잠시 저장할 수도 있으며 DB 를 통해서 영속화 하고 필요할 때 시스템으로 다시 불러올 수도 있다.

### Value Objects

꼭 모든 객체가 유일성을 보장해야 하지 않을 수도 있다.

예를 들어서 어떤 객체들은 단지 속성의 값으로만 존재할 수도 있다.

예를 들어서 우리의 컨퍼런스 관리 시스템에서 컨퍼런스 참석자의 주소에 대해서는 꼭 식별자를 갖지 않아도 된다.

대신 집중하는 것은 value object 는 불변성을 보장해야 한다는 것이다.

### Services

항상 모든것 객체 형태로 관리하지 않아도 된다.

예를 들어, 회의 관리 시스템에서는 외부 결제 처리 시스템을 서비스로 모델링하는 것이 합리적일 수 있다.

서비스가 필요로 하는 파라미터만 넘기고 결과를 반환받아 특정 기능을 수행할 수도 있다.

이러한 서비스의 특징이라고 한다면 엔티티나 값 객체와 달리 stateless 하다는 것이다.

# Aggregate 와 Aggregate Root

Entitiy, Value Object 및 Service 가 DDD 가 도메인 모델에서 존재하는 구성요소를 설명하는 데에 사용되는 용어인 반면에 Aggregate 나 Aggregate Root 라는 용어는 특히 그러한 용어들의 그룹화와 life-cycle 에 관련이 있다.

만약 공유된 데이터에 대해서 다수의 사용자를 허용하는 시스템을 설계한다면 당신은 consistency 와 usabililty 사이의 트레이드 오프를 잘 파악해야 한다.

극단적인 예를 보면, 유저가 어떠한 데이터에 대한 수정을 하고 있을 때, 시스템은 해당 데이터를 다른 사용자가 사용하지 못하도록 system 단에서 lock 을 걸 수 있다.

하지만 해당 lock 이 풀릴 떄 까지 시스템의 가용성은 낮아지게 된다.

또 다른 극단적인 예를 보자, 만약 다른 사용자가 사용하는 자원에 대해서 lock 을 걸지 않는다면, 다른 사용자들은 어떠한 제약 없이 동시에 해당 데이터를 수정할 수도 있고 시스템의 일관성이 깨지게 될 것이다.

이런 상황에서 locking 을 할 것이냐 말 것이냐를 결정하기 위해서는 해당 도메인에 대한 지식이 필요하다.

- 해당 트랜잭션을 통해서 어떤 값 객체나 엔티티가 영향을 받는지 알아야 한다.
- 한 오브젝트로 부터 다른 엔티티나 값 객체에 얼마나 영향을 미치며 어디까지 consistency 를 보장하는 경계에 대해서도 인지해야 한다.

### Aggregate

DDD 는 일관성을 보장해야 하는 관련된 엔티티와 값 객체들을 하나로 묶는 용어로 aggregate 라는 용어를 사용한다.

해당 consistency 경계는 일반적으로 transactional consistency 를 기본으로 한다.

> Aggregate 를 발음하면 애그리게이트 혹은 애그리거트라고 발음할 수 있다. 여기서 말하는 Aggregate 는 명사로 애그리거트- 라고 발음한다.

### Aggregate Root

root entity 로 알려진 Aggregate Root 는 애그리거트에 접근할 수 있는 진입접 (gatekeeper) 을 의미한다.

한 애그리거트에 속해있는 값 객체나 엔티티에 접근하기 위해서는 무조건 Aggregate Root 를 통해서만 수행되어야 한다.

외부 엔티티는 Aggregate Root 대한 레퍼런스만 가질 수 있다.

#### 요약하자면 aggregate 와 aggregate root 는 DDD 가 일반적으로 도메인 모델에 존재하는 수많은 엔티티와 값 객체 사이에 존재하는 복잡한 관계를 관리하는데 사용되는 메커니즘이다.

---
