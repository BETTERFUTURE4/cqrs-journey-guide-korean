<div align="center">

#### [목차 바로가기](https://github.com/dhslrl321/cqrs-journey-guide-korean/blob/master/Table%20of%20Contents.md)

</div>

---

# 최종 일관성과 CQRS

CQRS 패턴과 최종적 일관성은 어떤 연관이 있을까?

CQRS 패턴의 일반적인 구현은 하나의 노드는 쓰기 연산을 하고 다른 하나는 읽기 연산을 수행하는 분산 시스템이다.

만약 CQRS 를 구현한다고 한다면 양쪽의 데이터를 일관되게 유지하는 메커니즘이 필요하다.

이러한 동기화 과정은 한쪽에서만 쓰기 연산이 수행될 것이기 때문에 수정이 일어나면 단지 읽기 연산을 하는 쪽으로 변경 사항만 전달하면 되므로 크게 복잡하지 않다.

만약 양쪽 사이드 모두 항상 일관적이게 만들고 싶다면 (strong consistency), 아래의 그림과 같이 분산 트랜잭션을 도입해야 한다.

![image](https://user-images.githubusercontent.com/48385288/196939711-4fc806ae-524a-4959-8f36-b9f31ff9d7c3.png)

이러한 접근법에 대한 문제는 바로 성능과 가용성이다.

#### 첫째로, 양쪽 사이드는 commit 하기 전까지 lock 을 잡고있어야 한다.

즉, 트랜잭션에 대한 잠금으로 인한 대기가 많아질 것이다.

트랜잭션은 두개 이상의 노드가 포함될 수 있으며 여러 인스턴스를 추가해서 read side 를 scale out 하는 경우, 트랜잭션은 모든 인스턴스를 포함해야 한다

#### 둘쨰로, 어떠한 이유로든 하나의 노드가 실패한다면 혹은 트랜잭션이 성공하지 못한다면, 전체 트랜잭션이 실패하게 된다.

CAP 이론의 용어를 빌려보자면, consistecny 를 지키기 위해서 availability 를 포기해야 하는 상황이 온다.

일관성에 대한 제약을 조금 줄이고 read side 가 결국 write side 와 일치하도록 하는 경우는 트랜잭션 범위를 변경할 수 있다.

아래의 그림은 변경 사항을 전파하기 위해서 신뢰할 수 있는 메시징 인프라를 활용해 read side 를 결국 write side 로 일치시키는 방법을 보여준다.

![image](https://user-images.githubusercontent.com/48385288/196941948-51358927-fab4-408e-84e4-c2ddf2e6a0bb.png)

위 그림에서 여전히 트랜잭션이 존재하는 것을 볼 수 있다.

이 트랜잭션의 범위는 write side 의 데이터 저장소에 대한 변경 사항을 저장하고 변경 사항을 read side 에 push 하는 것을 포함한다.

이 방법은 메시징 인프라를 통해 대기열에 메시지를 빠르게 추가할 수 있다고 가정하면 앞서 이야기했던 일관성을 위한 전체 성능 저하 문제를 부분적으로 해결할 수 있다.

이러한 솔루션은 메시지 대기열이 read side 로 전달되는 메시지의 버퍼 역할을 수행하므로 더이상 모든 read side 의 인스턴스에 의존하지 않게 된다.

> 실제로, 메시징 인프라는 pub/sub 모델을 사용하고 일반적인 queue 를 사용하지는 않는다

이 세번쨰 예제는 분산 트랜잭션이 필요하지 않은 상황을 보여준다.

![image](https://user-images.githubusercontent.com/48385288/196943915-b4075d03-9426-4522-a166-3f3bd780489f.png)

위 예제는 쓰기쪽 데이터 저장소에의 기능에 따라서 다르다.

쓰기 측 모델이 데이터에 대한 모든 업데이트에 대한 응답으로 메시지를 모낼 수 있어야 한다.

이러한 접근 방식은 CQRS 와 이벤트 소싱을 결합하는 시나리오에 특히 적합하다.

이벤트스토어가 메시지 대기열에 저장하는 모든 이벤트의 복사본을 보낼 수 있다면, 이 인프라 기능을 이용해서 read side 를 일관되게 만들 수 있다.

---
