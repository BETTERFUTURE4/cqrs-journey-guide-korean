<div align="center">

#### [목차 바로가기](https://github.com/dhslrl321/cqrs-journey-guide-korean/blob/master/Table%20of%20Contents.md)

</div>

---

# Messaging 과 CQRS

CQRS 와 이벤트소싱은 두가지 유형의 메시지를 사용한다.

#### command 와 event

일반적으로 CQRS 패턴을 구현하는 시스템은 대규모 분산 시스템이므로 producer/consumer 및 publisher/subscriber 간의 메시지 전송에 신뢰할 수 있는 메시징 인프라가 필요하다.

단일 수신자가 있는 **command** 의 경우 일반적으로 queue topology 를 사용한다. 그리고 **event** 의 경우 여러 수신자가 있기 때문에 pub/sub 형태의 topology 를 사용한다.

이 가이드와 함께 제공되는 RI 는 메시징을 위해 windows azure service bus 를 사용한다. 7장 "Technology used in Reference Implementation" 에서는 이에 대한 추가 설명을 제공한다.

## messaging 을 도입할 때 필요한 고려사항

messaging 을 사용할 때, 몇가지 고려사항들이 존재한다.

이번 장에서는 Event 와 Command 를 사용하여 CQRS 를 구현하기 위해 가장 중요한 몇가지 이슈들에 대해서 이야기한다.

- message 중복
- message 유실
- message 순서 보장
- 처리되지 않은 메시지

### message 중복

메시징 인프라나 메시지를 수신하는 코드의 오류로 인해서 메시지는 수신자에게 여러번 전달될 수 있다.

이러한 문제를 해결할 수 있는 두가지 접근법이 존재한다.

- **메시지를 멱등하게 설계한다.**
  - 메시지를 멱등하게 설계해서 중복 메시지가 들어오더라도 데이터의 일관성이 깨지지 않도록 설계하는 방법이다.
- **중복 메시지를 찾는 로직을 구현한다.**
  - 몇몇의 메시징 인프라는 중복 검출에 대한 설정 전략을 지원하기 때문에 직접 구현하지 않고 이러한 인프라의 도움을 받을 수도 있다.

멱등 (idempotency) 에 대해서 더욱 자세히 알고싶다면 Pat Helland. 의“[Idempotence Is Not a Medical Condition](https://queue.acm.org/detail.cfm?id=2187821)” 에 대해서 확인하는 것도 추천한다

### message 유실

메시지 유실에 대한 문제도 처리해야 한다.

많은 메시징 인프라는 메시지가 손실되지 않고 수신자에게 적어도 한번 (At least once) 전달된다는 보증을 제공한다.

메시지가 손실되었을 때를 감지하기 위해 구현할 수 있는 대안에 대한 전략에 대해서는 발신자에게 수신에 대한 승인을 구하거나 수신자가 message 를 받지 못하였는지 알 수 있도록 message 에 sequence 번호를 할당하는 handshake process 가 필요하다

### message 순서 보장

메시징 인프라는 발신자가 메시지를 보낸 순서와 다른 순서로 수신자에게 메시지를 전달할 수 있다.

일부 시나리오에서 메시지가 수신되는 순서는 중요하지 않을 수 있지만 또 다른 시나리오에서는 중요할 수 있다.

메시지 순서가 중요하다면, 일부 메시징 인프라 구조는 순서를 보장해주는 제품들이 있을 것이다.

그렇지 않다면 전송되는 메시지에 sequence 번호를 할당하여 주문 외 메시지를 감지할 수 있다.

메시지를 올바른 순서로 정렬하기 까지 받은 메시지를 따로 저장하는 메커니즘을 process manager 에 해당 로직을 구현할 수도 있다.

특정 그룹 내에서 메시지를 정렬해야 하는 경우, 관련 메시지를 단일 배치로 보낼 수도 있으니 참고하라

### 처리되지 않은 메시지

클라이언트는 대기열에서 메시지를 검색한 다음 메시지를 처리하는 동안 실패할 수 있는데, 제대로 처리되지 않은 상태에서 클라이언트가 메시지를 다시 수신한다면 메시지가 손실된다.

일부 메시징 인프라를 사용하면 메시지 처리가 실패하였을 때 롤백할 수 있는 분산 트랜잭션의 일부로 인프라에서 메시지 읽기를 수행할 수 있다.

또한 특정 메시지 인프라에서 제공하는 또 다른 접근 방식을 메시지 읽기를 two-phase operation 으로 처리하는 것이다.

1. 먼저 메시지를 lock 한 뒤 읽는다.
2. message handling 이 끝나면 완료로 표시하고, 대기열에서 제거된다.

메시지가 완료로 표시되지 않으면, 메시지의 locking 시작이 초과되고 다시 읽을 수 있게 된다.

## Event Versioning

시스템이 진화할수록, 시스템에서 사용되는 Event 자체도 함께 진화할 것이다.

에를 들어

- 일부 이벤트는 시스템의 어떤 클래스에서도 더 이상 발생하지 않는다는 점에서 중복될 수 있다.
- 시스템 내의 새로운 기능이나 해당 기능과 관련된 새로운 이벤트를 정의해야 할 수도 있다.
- 기존 이벤트 payload 혹은 definition 을 수정해야 할 수도 있다.

이러한 시나리오에 대해서 설명해보겠다.

### Redundant events, 중복 이벤트

시스템이 더 이상 특정 이벤트 타입을 사용하지 않는다면, 시스템에서 간단히 제거할 수 있다.

하지만 이벤트소싱을 사용한다면, event store 는 이 이벤트의 많은 인스턴스를 보유할 수 있으며, 이러한 인스턴스는 애그리거트 상태를 replay 하는데 사용될 수 있다.

일반적으로 이벤트 스토어의 이벤트를 immutable 로 취급하는데, 애그리거트는 시스템이 더 이상 해당 이벤트 타입으로 새로운 인스턴스를 발생하지 않더라도 이벤트 스토어에서 replay 될 때 이러한 이벤트를 계속해서 처리할 수 있어야 한다.

### 새로운 이벤트 타입

시스템에 새로운 이벤트 타입을 추가하더라도 기존 동작에 영향을 미치지 않아야 한다.

일반적으로 새로운 이벤트 타입을 사용하는 것은 단지 새로운 기능이나 기능을 도입하는 것 뿐이다.

### 존재하는 이벤트 payload 혹은 definition 정의

이벤트 타입 정의의 변경 사항을 처리하려면 시스템에 더 복잡한 변경이 필요하다.

예의 경우, 이벤트 스토어는 이전 버전의 이벤트 타입의 많은 인스턴스를 보유할 수 있으며, 시스템은 이후 버전인 이벤트를 발행시키거나, 다른 바운디드 컨텍스트는 동일한 이벤트의 다른 버전을 발행할 수 있다.

시스템은 동일한 이벤트의 여러 버전을 처리할 수 있어야 한다.

#### 이벤트의 버전은 다양한 이유에 의해서 변경될 수 있다.

- 이벤트에 새로운 프로퍼티가 추가되었다.
- 이벤트에 특정 프로퍼티가 삭제되었다.
- 프로퍼티의 속성의 데이터 타입이 변경되었다.

> 이벤트의 sementic 의미가 변경되면, 기존 이벤트의 새 버전이 아닌 새로운 이벤트 유형으로 취급해야 합니다.

여러 버전의 이벤트 타입이 있는 경우, 여러 버전을 처리하는 방법에 대한 두가지 기본 선택사항이 있다.

1. 도메인 클래스에서 여러 버전의 이벤트를 계속해서 지원한다.
2. 특정 로직을 통해 시스템에서 발생할 때 마다 이전 버전의 이벤트를 최신 버전으로 변환할 수 있다.

#### 첫번째 방법의 경우 일반적으로 인프라를 변경할 필요가 없기 때문에 채택하기 쉽고 빠르다.

하지만 이 방법으로 계속할 경우 버전 별로 처리해야 하는 코드가 달라지므로 도메인 클래스가 오염될 것이다. 하지만 이벤트 정의에 많은 변화가 없을 것으로 보인다면 이러한 방법도 괜찮은 선택이다.

#### 두번째 접근 방식은 도메인을 더 깔끔하게 만들 수 있다.

도메인 클래스는 각 이벤트 타입의 최신 버전만 지원하게 된다. 그러나 이전 버전의 이벤트를 최신으로 변환하려면 인프라를 변경해야 한다.

여기서 문제는 이 변환 작업을 위해 인프라가 변경된다는 것이다.

한가지 옵션인 메시징 인프라에 필터링 기능을 추가해서 이벤트가 수신자에게 전달될 때 EventHandler 에 변환 기능을 추가하여 자동 변환되도록 하는 것이다.

이벤트 소싱을 사용하는 경우에 애그리거트로 hydration 과정에서 이벤트 스토어에서 read 할 때 이전 버전의 이벤트가 잘 변환되었는지 확인해야 한다.

어떤 솔루션을 채택하던 이러한 변환 작업은 필수적인 것이다.

직렬화 방식을 선택하면 다양한 버전의 이벤트를 더욱 쉽게 처리할 수 있다. 예를 들어서 JSON 역직렬화는 단순히 삭제된 속성을 무시하거나 객체가 역직렬화된 클래스에 새로운 프로퍼티에 기본 값을 세팅하게 할 수 있다.

---
